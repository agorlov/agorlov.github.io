---
title: "Декларативное ООП, переводы"
date: 2018-05-05
tags: ооп
description: |
  Статьи и переводы по декларативному ООП, когда продукт проектируется 
  от предметной области.  
keywords:
  - декларативное и императивное программирование
  - объекты и классы
  - объектно ориентированное программирование
---

## Декларативное ООП

Собираю тут все о **Декларативном ООП**.

Программа проектируется, описывая объектами и их композицией **желаемый результат**.

В императивном, мы действуем иначе &mdash; проектируем программу перечисляя список инструкций для компьютера,
выполнив которые получим результат.

Естественно, что если код формулирует результат, а объект скрывает реализацию &mdash; это на порядок понятнее для человека,
чем читать список инстркций для компьютера. Именно это определяет **поддерживаемость декларативного кода**.

<!-- ООП дает избыточный инструментарий, позволяет его применять, но нужно менять привычки. -->

<!-- Для неболших проектов нет большой разницы, как проектировать, но как только продукт становится средним или
большим можно пожалеть о выборе императивного подхода в самом его начале.  -->

### Переводы

01.05.2018 Нашел перевод [Семь смертных грехов разработки ПО](https://habr.com/post/260241/)

29.04.2018 Перевел пост [Семь качеств хорошего объекта](/yb-seven-virtues-of-good-object.html)

07.04.2018 Перевел пост [Объект, это кто?](/yb-object.html)


### ООП и языки

Самые используемые сейчас языки программирования: Java, C++, python, PHP, Javascript, Ruby
все они являются **языками общего назначения** 

Они позволяют применять любые подходы:
- процедурный 
- объектный
- функциональный

Разработчики так и делают &mdash; смешивают их.

### Переводы постов Егора Бугаенко: новый взгляд на ООП

Сейчас редко можно встретить код, где нет **неосознанного** 
смешения техник из различных парадигм: процедурная, функциональная, объектная.

В итоге многие сталкиваются с тем, что глядя на свой код (не говоря уже о чужом) 
он кажется им непонятным, нелогичным, устаревшим - _неподдерживаемым_.

<!-- 
Распространенный миф: если разработчик пишет классы, он думает, что его код 
объектный. В большинстве случаев это не так. Если взглянуть на такие классы, 
часто это наборы процедур, и если в процедурном программировании их группировали в 
модули, то с появлением классов их стали объединять классами. 

Класс это маленький самодостаточнй механизм, выполняющий свою роль. Класс представляет
понятие из предметной области.
-->


Цель подхода **EO** в том, чтобы код был объектным и оставался **поддерживаемым**.

Вот основные принципы:

- Декларативность вместо имеративности &mdash; программа описывает результат, а не перечисялет инструкции, как его достичь
(инструкции понятны компьютерам, результат понятен людям);
- Проектирование от предметной области (результата), а не от данных; (сначала проектруют базу, потом классы,
получается data-driven design, вместо **domain driven**)
- Имена объектов отвечают на вопрос **Кто**, а не _Что он делает_ (объекты это представители сущностей предметной области);
- Объекты компактны (несколько методов, в конструкторах несколько параметров) до 5-7;
- Объекты расширяются декораторами (не наследованием) (why? and why?);
- Объекты и декораторы легко стыкуются благодаря интерфейсам;
- Легкие конструкторы: не содержат кода, только инициализация состояния;
- Не используется null (why?);
- Не используются статические методы, в том числе приватные (это аналог глобальных функций и процедур);
- нет сеттеров и геттеров;
- Не используется instanceof, type casting или рефлексия;
- Все публичные методы объявлены в интерфейсе;
- Все проверки в юнит-тестах только ``assertThat`` (why?)
- Группировка композиции объектов с помощью ``Объектов оболочек`` (Deocrating Envelopes/Wraps)
аналог: группировки при создании векторных изображений - несколько линий сгруппировали, получилась фигрура)
- Расширяющие/Уточняющие интерфейсы (Smart) - позволяют 


<!-- - Все new только в конструкторе -->





