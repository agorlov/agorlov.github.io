Оригинал: http://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html

# Семь качеств хорошего объекта

Мартин Фаулер [сказал](http://martinfowler.com/bliki/InversionOfControl.html):

> Библиотека это набор функций, которые вы можете вызвать, сейчас не редко оформляется в виде класса.

Функции, организованные в классы? При всем уважении, но это не правильно. 
Это типичное заблуждение о классе в объектно-ориентированном программировании.
Классы это не органайзеры для функций. И объекты это не структуры данных.

Так каков же "правильный" объект? А какой не правильный? И в чем разница?
Не смотря на то что данная тема является предметом дискуссий, она очень важна.
Пока мы не понимаем, что такое объект, как мы можем разрабатывать объектно-ориентированные программы?
Хотя, благодаря Java, Ruby и другим, мы можем. Но насколько хороши они будут?
К сожалению, нет точной науки, и существует большое количество мнений. 
Я приведу мой список качеств хорошего объекта.



## Класс vs. Объект

badge

Перед тем, как начать разговор об объектах, давайте определим что такое класс. Это место, где рождаются объекты (создаются экземпляры).
Основное предназначение класса - создавать новые объекты и уничтожать их, когда они больше не используются. Класс знает какими должны
быть его дети и как они должны себя вести. Другими словами, он знает какие контракты они должны соблюдать.

YouTube video #WSgP85kr6eU
Why Getters-and-Setters Is An Anti-Pattern? (webinar #4); 1 July 2015.

Иногда я слышу, классы также известны как "шаблоны объектов" (например, в Википедии так говорится). Это определение неверно, 
потому что оно ставит классы в пассивное положение. Говоря технический, это может быть и так, но концептуально неправильно.
Только класс и его дети должны учавствовать и больше никто. Объект просит класс создать другой объект и класс создает его; и только.
На Ruby эта концепция выражена гораздо лучше чем в Java и C++:

```
photo = File.new('/tmp/photo.png')
```

Объект ``photo`` создается классом ``File`` (new это входная точка класса). Как только создали, объект начинает действовать самостоятельно. Ему не нужно знать, кем он создан и сколько в его классе братьев и сестер. Верно, я считаю что рефлексия это
ужасная идея, я напишу подробнее об этом в одном из следующих  постов :) Теперь, давайте поговорим об объектах и их лучших и худших сторонах.

## 1. Он существует в реальной жизни

В первую очередь, объект это живой организм.  Более того, объект должен быть антропоморфизирован, т. е. рассматриваться как человек (или домашнее животное, если они вам больше нравятся). Под этим я в основном подразумеваю, что объект это не структура данных или коллекция функций. Наоборот, это независимая сущность со своим жизненным циклом, собственным поведением и своими привычками.

Сотрудник, отдел, HTTP-запрос, таблица в MySQL, строка в файле или файл сам по себе правильные объекты, потому что они существуют
в реальной жизни, даже когда наша программа не работает. Чтобы быть точнее, объект это представитель реального существа. 
Это прокси этого реального существа (за ним могут стоять другие объекты). Без этого существа, очевидно, нет и объекта.

```
photo = File.new('/tmp/photo.png')
puts photo.width()
```

В этом примере, я прошу ``File`` создать новый объект ``photo``, который будет представлять реальный файл на диске. Вы можете 
сказать, что файл это что-то не настоящее и существует только когда компьютер включен. Я соглашусь и уточню определение 
"реальной жизни": это все, что существует за рамками программы в которой живет объект. Файл на диске находится за рамками нашей
программы; поэтому совершенно правильно создать его представителя в программе.

Контроллер, парсер, фильтр, валидатор, сервис локатор, синглтон или фабрика примеры плохих объектов (да, большинство GoF шаблонов являются анти-патернами!). Они не существуют в реальной жизни, за рамками вашей программы. Они придуманы только для того чтобы
связать вместе другие объекты. Они искуственные и поддельные существа. Они ни кого не представляют. Серьезно, кого представляет
XML-парсер? Никого.

Некоторые из них могут стать хорошими если их переименовать; другие никогда не смогут оправдать свое существование. Например, этот
XML parser, может быть переименован в "parseable XML" и начать представлять XML-документ, который существует за пределами нашей
области.

Всегда задавайте себе вопрос, "Какая реальная сущность стоит за моим объектом?" Если вы не можете ответить, начинайте думать о рефакторинге.


## 2. Он работает по договору

badge

Хороший объект всегда работает по договорам. Его нанимают не за его личные заслуги, а потому, что он подчиняется договору.
С другой стороны, нанимая объект, мы не должны дискриминировать и ожидать, что это будет определенный объект определенного
класса. Мы должны ожидать что любой объект будет выполнять то, что говорится в договоре.
Пока объект делает то, что нам нужно, нас не должен интересовать его класс происхождения, его пол или его религия.

Например, мне нежуно показать фото на экране. Я хочу, чтобы это фото читалось из файла в PNG формате. Я подписываю
объект из класса DataFile и прошу его дать мне бинарный контент этого изображения.

For example, I need to show a photo on the screen. I want that photo to be read from a file in PNG format. I'm contracting an object from class DataFile and asking him to give me the binary content of that image.

But wait, do I care where exactly the content will come from—the file on disk, or an HTTP request, or maybe a document in Dropbox? Actually, I don't. All I care about is that some object gives me a byte array with PNG content. So my contract would look like this:

interface Binary {
  byte[] read();
}
Now, any object from any class (not just DataFile) can work for me. All he has to do, in order to be eligible, is to obey the contract—by implementing the interface Binary.

The rule here is simple: every public method in a good object should implement his counterpart from an interface. If your object has public methods that are not inherited from any interface, he is badly designed.

There are two practical reasons for this. First, an object working without a contract is impossible to mock in a unit test. Second, a contract-less object is impossible to extend via decoration.
